1.volatile 
------
    在多处理器下，为了保证各个处理器的缓存是一致的，就会实现**缓存一致性**协议，**每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期**了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器对这个数据进行修改操作的时候，会重新从系统内存中把数据读到处理器缓存里。
    
    1.1 在生成汇编代码时会对volatile修饰的共享变量进行写操作的时候会多出Lock前缀的指令，Lock前缀的指令会引起处理器缓存写回内存。
    1.2 一个处理器的缓存回写到内存会导致其他处理器的缓存失效。
    1.3 当处理器发现本地缓存失效后，就会从内存中重读该变量数据，即可以获取当前最新值。
      volatile变量通过这样的机制就使得每个线程都能获得该变量的最新值。
      
    volatile：jdk提供的一种轻量级的同步机制，保证不同线程间对共享变量操作的可见性，阻止编译器和处理器的指令重排(通过添加JMM内存屏障)，但是不保证原子性
      
 2.CAS
 ------
    compare and swap保证变量的原子性操作
    CAS机制中，使用三个操作数：内存地址V，旧的预期值A，要修改的新值B
    更新一个变量的时候，只有当旧的预期值A和内存地址V中的实际值相同时，才会将内存地址V对应的值修改为B
    底层实现：利用unsafe提供的原子性操作方法，unsafe是底层硬件级的操作
    
    CAS通过自旋实现，1.获取当前值2.当前值+1，计算出目标值3.进行CAS操作，成功就跳出循环，失败就重复上述步骤
    缺点：CPU开销过大，不能保证代码块的原子性，ABA问题
    ABA问题：线程1：A->B
             线程2：阻塞
             线程3：B->A
             线程2：阻塞完成，A->B
             
    ABA问题解决：值+版本号
                例如：AtomicStampedReference类实现了带版本号的CAS机制

3.公平锁+非公平锁
------
    公平锁：指多个线程按照申请锁的顺序来获取锁，先来后到，早到早得
    非公平锁：指多个线程获取锁的顺序并非按照申请锁的顺序，有可能后申请的线程比先申请的线程要更早的获取到锁。
    非公平锁的优点在于吞吐量比公平锁大
    Synchronized锁是一种非公平锁
    ReentrantLock锁可以根据析构函数的参数决定是公平锁还是非公平锁。
  
4.可重入锁  
------
    作用是防止死锁  
    线程获取锁后可以重复执行锁区域。Java提供的锁都是可重入锁。不可重入锁非常容易导致死锁。  
5.共享锁
------
    线程可以同时获取锁。ReentrantReadWriteLock对于读锁是共享的，在读多写少的情况下使用共享锁会非常高效。  
6.排它锁
------
    多线程不可同时获取的锁。与共享锁对立。与可重入锁不矛盾可以是并存属性。  
7.偏向锁  
------
    一段同步代码一直被一个线程所访问，那么该线程会自动获取所。降低获取锁的代价，类似于乐观锁。  
8.轻量级锁  
------
    当锁是偏向锁的时候，被另一个线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的方式尝试获取锁，不会阻塞，提高性能。  
9.重量级锁  
------
    当锁是轻量级锁的时候，另一个线程虽然是自旋，但自旋不会一直持续下去，当自旋一定次数的时候，还没有获取到锁，就会进入阻塞，该锁会膨胀为重量级锁，重量级锁会让其他申请的线程进入阻>>塞， 性能降低。  
10.分段锁  
------
    分段锁是一种锁思想，对数据分段加锁提高并发效率，比如jdk8之前的ConcurrentHashMap(采用分段锁+数组+链表)，jdk8之后CAS+Synchronized。  
    当需要PUT元素的时候，并不是对整个hashmap进行加锁，而是先通过hashcode来知道它要放在哪一个分段中，然后对这个分段进行加锁，所以当多线程put的时候，只要不是放在一个分段中，  
    就实现了真正的并行插入。  
    分段锁的设计目的是细化锁的粒度，当操作不需要更新整个数组的时候，就仅仅对数组中的一项进行加锁操作。  
11.自旋锁  
------
    是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁，这样的好处是减少线程上下文切换的消耗，缺点是循环会消耗CPU  
