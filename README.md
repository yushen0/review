1.volatile 
    在多处理器下，为了保证各个处理器的缓存是一致的，就会实现**缓存一致性**协议，**每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期**了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器对这个数据进行修改操作的时候，会重新从系统内存中把数据读到处理器缓存里。
    
    1.1 在生成汇编代码时会对volatile修饰的共享变量进行写操作的时候会多出Lock前缀的指令，Lock前缀的指令会引起处理器缓存写回内存。
    1.2 一个处理器的缓存回写到内存会导致其他处理器的缓存失效。
    1.3 当处理器发现本地缓存失效后，就会从内存中重读该变量数据，即可以获取当前最新值。
      volatile变量通过这样的机制就使得每个线程都能获得该变量的最新值。
      
    volatile：jdk提供的一种轻量级的同步机制，保证不同线程间对共享变量操作的可见性，阻止编译器和处理器的指令重排(通过添加JMM内存屏障)，但是不保证原子性
      
 2.CAS
    compare and swap保证变量的原子性操作
    CAS机制中，使用三个操作数：内存地址V，旧的预期值A，要修改的新值B
    更新一个变量的时候，只有当旧的预期值A和内存地址V中的实际值相同时，才会将内存地址V对应的值修改为B
    底层实现：利用unsafe提供的原子性操作方法，unsafe是底层硬件级的操作
    
    CAS通过自旋实现，1.获取当前值2.当前值+1，计算出目标值3.进行CAS操作，成功就跳出循环，失败就重复上述步骤
    缺点：CPU开销过大，不能保证代码块的原子性，ABA问题
    ABA问题：线程1：A->B
             线程2：阻塞
             线程3：B->A
             线程2：阻塞完成，A->B
             
    ABA问题解决：值+版本号
                例如：AtomicStampedReference类实现了带版本号的CAS机制

